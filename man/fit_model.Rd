% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_model.R
\name{fit_model}
\alias{fit_model}
\title{Fit VAST to data}
\usage{
fit_model(
  settings,
  Lat_i,
  Lon_i,
  t_i,
  b_i,
  a_i,
  c_iz = rep(0, length(b_i)),
  v_i = rep(0, length(b_i)),
  working_dir = tempdir(),
  X1config_cp = NULL,
  X2config_cp = NULL,
  covariate_data,
  X1_formula = ~0,
  X2_formula = ~0,
  Q1config_k = NULL,
  Q2config_k = NULL,
  catchability_data,
  Q1_formula = ~0,
  Q2_formula = ~0,
  newtonsteps = 1,
  silent = TRUE,
  build_model = TRUE,
  run_model = TRUE,
  test_fit = TRUE,
  category_names = NULL,
  year_labels = NULL,
  framework = "TMBad",
  use_new_epsilon = TRUE,
  ...
)
}
\arguments{
\item{settings}{Output from \code{\link{make_settings}}}

\item{Lat_i}{Numeric vector, providing latitude for each sample}

\item{Lon_i}{Numeric vector, providing longitude for each sample}

\item{t_i}{Vector of integers, providing the time (e.g., calendar year) for each observation i.
The first modeled interval will be \code{min(t_i)}, and last will be \code{max(t_i)},
and every interval corresponding to integers between \code{min(t_i)} and \code{max(t_i)} will also be modeled.}

\item{b_i}{Vector, providing sampled value (biomass, counts, etc.) for each observation i.
Users should provide values as class \code{\link[units]{units}}, e.g., \code{as_units(x, "kg")} for data in units kilograms,
\code{as_units(x, "count")} for numbers, or \code{as_units(x, "kg/km^2")} for area-standarized biomass, etc.
If units are missing, the default behavior is to coerce the vector to units "kg".
Units are then used in subsequent plotting. Users can also specify \code{b_i=NA} for some observations,
e.g., when seeking to ensure that the model includes hindcast/forecast years that do not otherwise have sampling data}

\item{a_i}{Vector containing values greater than zero, providing sampled area for each
observation i, e.g., \code{as_units(x, "km^2")} for area swept in square-kilometers.
use \code{as_units(1, unitless)} for observations without a natural area measurement
(noting that resulting densities no longer have interpretable units in that case),
or for observations where the response \code{b_i} already standardizes for area, e.g.,
\code{b_i = as_units(x, "kg/km^2")}}

\item{c_iz}{Vector of integers ranging from 0 to the number of variables minus 1, providing the
category (e.g., species, length-bin) for each observation i.
This can be specified as a matrix, such that each observation is associated with multiple categories.
Such specification treats samples as arising from the sum across multiple categories, e.g.,
to account for unlabeled multispecies data.}

\item{v_i}{Vector of integers ranging from 0 to the number of vessels minus 1,
providing sampling category (e.g., vessel or tow) associated with overdispersed variation for each observation i
(by default \code{v_i=0} for all samples, which will not affect things given the default values for \code{OverdispersionConfig}).
In some cases a portion of observations have a overdispersion-effect, but not others, and in this case the observations without
are specified as \code{v_i=NA}}

\item{X1config_cp}{matrix of settings for each density covariate for the 1st lienar predictor,
       where the row corresponds to model category, and column corresponds to each density covariate
\describe{
  \item{\code{X1config_cp[c,p]=0}}{\code{X_ip[,p]} has no effect on the 1st linear predictor for category c}
  \item{\code{X1config_cp[c,p]=1}}{\code{X_ip[,p]} has a linear effect on 1st linear predictor for category c}
  \item{\code{X1config_cp[c,p]=2}}{\code{X_ip[,p]} has a spatially varying, zero-centered linear effect on 1st linear predictor for category c}
  \item{\code{X1config_cp[c,p]=3}}{\code{X_ip[,p]} has a spatially varying linear effect on 1st linear predictor for category c}
  \item{\code{X1config_cp[c,p]=4}}{Replaces covariate \code{X_ip[,p]} with \code{beta1_tc[,c]+beta2_tc[,c]} for the corresponding
                                            year and category, which has a zero-centered spatially varying effect on 1st linear predictor.
                                            This then represents a density-dependent effect on distribution. (NOTE: still in beta testing)}
  \item{\code{X1config_cp[c,p]=-1}}{\code{X1config_cp[c,p]=-1} is the same as \code{X1config_cp[c,p]=2}, but without including the log-likelihood term; this is useful in special cases when carefully mirroring spatially varying coefficients, e.g., to use cohort effects in a age-structured spatio-temporal model}
}}

\item{X2config_cp}{Same as argument \code{X1config_cp} but for 2nd linear predictor}

\item{covariate_data}{data frame of covariate values with columns \code{Lat}, \code{Lon}, and \code{Year}, and other columns matching names in \code{formula}; \code{Year=NA} can be used for covariates that do not change among years (e.g., depth)}

\item{X1_formula}{right-sided formula affecting the 1st linear predictor
which is then estimated independently for each model category \code{c_i}, e.g.,
use \code{X1_formula=~BOT_DEPTH+BOT_DEPTH^2} for a quadratic effect of variable \code{BOT_DEPTH}
that is estimated independently for each category.
The effect of an estimated effect is also used when predicting the value for each location
in the extrapolation-grid.  Therefore, \code{X1_formula} is interepreted as affecting the "true"
underlying value of each variable, and it affects both samples and extrapolated values.
It is allowed to include \code{Year} in the formula, although please check whether it is
interpreted as numeric or factor-valued.
Note that \code{X1_formula} is internally updated (and resulting design-matrices are modified) to avoid
any intercept from arising in \code{X1_ip} and \code{X1_gctp}, to avoid identifiability issues between covariates and
intercepts for each category.}

\item{X2_formula}{same as \code{X1_formula} but affecting the 2nd linear predictor.}

\item{Q1config_k}{Same as argument \code{X1config_cp} but affecting affecting the 1st linear predictor for catchability,
and note that it is a vector (instead of matrix) given that catchability responses do not vary among variables \code{c}
by default (but can be specified to do so when an appropriate `formula` is supplied)}

\item{Q2config_k}{Same as argument \code{Q1config_cp} but affecting affecting the 2nd linear predictor for catchability}

\item{catchability_data}{data-frame of covariates for use when specifying \code{Q1_formula} and \code{Q2_formula}}

\item{Q1_formula}{Similar to \code{X1_formula}, \code{Q1_formula} affects the 1st linear predictor for samples.
However, the effect of \code{Q1_formula} is not used when predicting values at extrapolation-grid locations.
Therefore, the \code{Q1_formula} is interpreted as affecting "catchability" (a.k.a. "detectabiility"), and it represents
processes that affect the outcome of sampling but not the "true" underlying value of a variable being sampled.
For example, to estimate the relative performance of differeng gear types, include \code{catchability_data = data.frame(gear=gear_factor)}
where \code{gear_factor} is a factor-valued indicator for different gear types and \code{Q1_formula = ... + gear},
and this will estimate the catchability for each level relative to the base level of that factor.
Note that \code{Q1_formula} defines a relationship that is applied to all samples (regardless of category \code{c_i}),
whereas \code{X1_formula} defines a relationship that is estimated independently for each category.
Also note that \code{\link{make_data}} includes \code{c_iz[,1]} as a column labeled \code{category} in \code{catchability_data},
and that \code{Q1_formula} is internally updated (and resulting design-matrices are modified) to avoid
any category-specific intercept from arising in \code{Q1_ik}, to avoid identifiability issues between category-specific
covariates and intercepts.
For example, for a catchability covariate that varies by category, include an interaction with category in \code{Q1_formula},
e.g., \code{Q1_formula = ... + category:gear} where \code{gear} is a factor to estimate category-specific catchability ratio for
different levels of \code{gear}.}

\item{Q2_formula}{same as \code{Q2_formula} but affecting the 2nd linear predictor.}

\item{newtonsteps}{Integer specifying the number of extra newton steps to take
after optimization (alternative to \code{loopnum}).
Each newtonstep requires calculating the Hessian matrix and is therefore slow.
But for well-behaved models, each Newton step will typically
decrease the maximum gradient of the loglikelihood with respect to each fixed effect,
and therefore this option can be used to achieve an arbitrarily low final gradient
given sufficient time for well-behaved models.  However, this option will also
perform strangely or have unexpected consequences for poorly-behaved models, e.g.,
when fixed effects are at upper or lower bounds.}

\item{build_model}{Boolean indicating whether to build the model, \code{build_model=TRUE}, or simply build the inputs, \code{build_model=FALSE}}

\item{run_model}{Boolean indicating whether to run the model or simply return the inputs and built TMB object}

\item{test_fit}{Boolean indicating whether to apply \code{\link[VAST]{check_fit}} before calculating standard errors, to test for parameters hitting bounds etc; defaults to TRUE}

\item{category_names}{character vector specifying names for labeling categories \code{c_i}}

\item{year_labels}{character vector specifying names for labeling times \code{t_i}}

\item{framework}{Which AD framework to use ('TMBad' or 'CppAD')}

\item{...}{additional arguments to pass to \code{\link{make_extrapolation_info}}, \code{\link{make_spatial_info}}, \code{\link[VAST]{make_data}}, \code{\link[VAST]{make_model}}, or \code{fit_tmb},
where arguments are matched by name against each function.  If an argument doesn't match, it is still passed to \code{\link[VAST]{make_data}}.  Note that \code{\link{make_spatial_info}}
passes named arguments to \code{\link[fmesher]{fm_mesh_2d}}.}
}
\value{
Object of class \code{fit_model}, containing formatted inputs and outputs from VAST
\describe{
\item{\code{parameter_estimates}}{Output from \code{fit_tmb}; see that documentation for definition of contents}
\item{\code{extrapolation_list}}{Output from \code{\link{make_extrapolation_info}}; see that documentation for definition of contents}
\item{\code{spatial_list}}{Output from \code{\link{make_spatial_info}}; see that documentation for definition of contents}
\item{\code{data_list}}{Output from \code{\link[VAST]{make_data}}; see that documentation for definition of contents}
\item{\code{tmb_list}}{Output from \code{\link[VAST]{make_model}}; see that documentation for definition of contents}
\item{\code{ParHat}}{Tagged list of maximum likelihood estimatesion of fixed effects and empirical Bayes estimates of random effects, following format of initial values generated by \code{\link[VAST]{make_parameters}}; see that documentation for definition of contents}
\item{\code{Report}}{Tagged list of VAST outputs. For example, estimated density for grid \code{g}, category \code{c}, and time \code{y} is available as \code{fit$Report$D_gcy[g,c,y]}; see Details section for description of indexing}
}
}
\description{
This function is the user-interface for the multiple mid-level functions that
perform separate components of a spatio-temporal analysis:
\itemize{
\item determine the extrapolation-grid \code{\link{make_extrapolation_info}},
\item define spatial objects \code{\link{make_spatial_info}},
\item build covariates from a formula interface \code{\link{make_covariates}},
\item assemble data \code{\link[VAST]{make_data}},
\item build model \code{\link[VAST]{make_model}},
\item estimate parameters \code{fit_tmb}, and
\item check for obvious problems with the estimates \code{\link[VAST]{check_fit}}.
}
Please see reference documetation for each of those functions (e.g., \code{?make_extrapolation_info}) to see a list of arguments used by each mid-level function.
}
\details{
Specifically, the mid-level functions called by \code{fit_model(.)} look for arguments in the following order of precedence (from highest to lowest precedence):
\enumerate{
\item \code{fit_model(.)} prioritizes using named arguments passed directly to \code{fit_model(.)}. If arguments are passed this way, they are used instead of other options below.
\item If an argument is not passed supplied directly to \code{fit_model(.)}, then \code{fit_model(.)} looks for elements in input \code{settings}, as typically created by \code{\link{make_settings}}.
\item If an argument is not supplied via (1) or (2) above, then each mid-level function uses default values defined in those function arguments, e.g., see \code{args(make_extrapolation_info)} for defaults for function \code{make_extrapolation_info(.)}
}
Collectively, this order of precedence allows users to specify inputs for a specific project via input method (1), the package author to change defaults through changes in the settings
defined for a given purpose in \code{make_settings(.)} via input method (2), while still defaulting to package defaults via option (3).

Variables are indexed internally for locations \code{g}, categories \code{c}, and times \code{y}.
Location index \code{g} represents Longitude-Latitude \code{fit$extrapolation_list$Data_Extrap[which(fit$spatial_list$g_e==g),c('Lon','Lat')]};
Time index \code{y} represents time \code{fit$year_labels}; and
Category \code{g} corresponds to values in \code{fit$data_list$g_i}.
}
\examples{
\dontrun{
# Load packages
library(VAST)

# load data set
# see `?load_example` for list of stocks with example data
# that are installed automatically with `VAST`.
example = load_example( data_set="EBS_pollock" )

# Make settings
settings = make_settings( n_x=50,
         Region=example$Region,
         purpose="index",
         strata.limits=example$strata.limits )

# Run model
fit = fit_model( "settings"=settings,
    "Lat_i"=example$sampling_data[,'Lat'],
    "Lon_i"=example$sampling_data[,'Lon'],
    "t_i"=example$sampling_data[,'Year'],
    "c_i"=rep(0,nrow(example$sampling_data)),
    "b_i"=example$sampling_data[,'Catch_KG'],
    "a_i"=example$sampling_data[,'AreaSwept_km2'],
    "v_i"=example$sampling_data[,'Vessel'] )

# Plot results
plot_results( settings=settings, fit=fit )
}

}
\seealso{
\code{\link[VAST]{VAST}} for general documentation, \code{\link{make_settings}} for generic settings, \code{\link{fit_model}} for model fitting, and \code{\link{plot_results}} for generic plots

VAST wiki \url{https://github.com/James-Thorson-NOAA/VAST/wiki} for examples documenting many different use-cases and features.

GitHub mainpage \url{https://github.com/James-Thorson-NOAA/VAST#description} for a list of user resources and publications documenting features

\code{\link{summary.fit_model}} for methods to summarize output, including obtain a dataframe of estimated densities and an explanation of DHARMa Probability-Integral-Transform residuals

\code{\link{predict.fit_model}} for methods to predict at new locations using existing or updated covariate values

Other wrapper functions: 
\code{\link{make_settings}()},
\code{\link{plot_results}()}
}
\concept{wrapper functions}
