% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_model.R
\name{predict.fit_model}
\alias{predict.fit_model}
\title{Predict density for new samples (\emph{Beta version; may change without notice})}
\usage{
\method{predict}{fit_model}(
  x,
  what = "D_i",
  Lat_i,
  Lon_i,
  t_i,
  a_i,
  c_iz = rep(0, length(t_i)),
  v_i = rep(0, length(t_i)),
  new_covariate_data = NULL,
  new_catchability_data = NULL,
  do_checks = TRUE,
  working_dir = getwd()
)
}
\arguments{
\item{x}{Output from \code{\link{fit_model}}}

\item{what}{Which output from \code{fit$Report} should be extracted; default is predicted density}

\item{t_i}{Vector of integers, providing the time (e.g., calendar year) for each observation i.
The first modeled interval will be \code{min(t_i)}, and last will be \code{max(t_i)},
and every interval corresponding to integers between \code{min(t_i)} and \code{max(t_i)} will also be modeled.}

\item{a_i}{Vector containing values greater than zero, providing sampled area for each
observation i, e.g., \code{as_units(x, "km^2")} for area swept in square-kilometers.
use \code{as_units(1, unitless)} for observations without a natural area measurement
(noting that resulting densities no longer have interpretable units in that case),
or for observations where the response \code{b_i} already standardizes for area, e.g.,
\code{b_i = as_units(x, "kg/km^2")}}

\item{c_iz}{Vector of integers ranging from 0 to the number of variables minus 1, providing the
category (e.g., species, length-bin) for each observation i.
This can be specified as a matrix, such that each observation is associated with multiple categories.
Such specification treats samples as arising from the sum across multiple categories, e.g.,
to account for unlabeled multispecies data.}

\item{v_i}{Vector of integers ranging from 0 to the number of vessels minus 1,
providing sampling category (e.g., vessel or tow) associated with overdispersed variation for each observation i
(by default \code{v_i=0} for all samples, which will not affect things given the default values for \code{OverdispersionConfig}).
In some cases a portion of observations have a overdispersion-effect, but not others, and in this case the observations without
are specified as \code{v_i=NA}}

\item{keep_old_covariates}{Whether to add new_covariate_data to existing data.
This is useful when predicting values at new locations, but does not work
when predicting data are locations with existing data (because the interpolation of
covariate values will conflict for existing and new covariate values), e.g.,
when calculating partial dependence plots for existing data.}
}
\description{
\code{predict.fit_model} calculates predictions given new data
}
\details{
\code{predict.fit_model} is designed with two purposes in mind:
\enumerate{
\item If \code{new_covariate_data=NULL} as by default, then the model uses the covariate values supplied during original model fits,
      and interpolates as needed from those supplied values to new predicted locations.  This then uses *exactly* the same information
      as was available during model fitting.
\item If \code{new_covariate_data} is supplied with new values (e.g., at locations for predictions), then these values are used in
      combination with original covariate values when interpolating to new values.  However, supplying \code{new_oovariate_data}
      at the same Lat-Lon-Year combination as any original covariate value will delete those matches in the latter, such that originally fitted data
      can be predicted using alternative values for covariates (e.g., when calculating partial dependence plots)
}
}
\examples{
\dontrun{

# Showing use of package pdp for partial dependence plots
pred.fun = function( object, newdata ){
  predict( x=object,
    Lat_i = object$data_frame$Lat_i,
    Lon_i = object$data_frame$Lon_i,
    t_i = object$data_frame$t_i,
    a_i = object$data_frame$a_i,
    what = "P1_iz",
    new_covariate_data = newdata,
    do_checks = FALSE )
}

library(ggplot2)
library(pdp)
Partial = partial( object = fit,
                   pred.var = "BOT_DEPTH",
                   pred.fun = pred.fun,
                   train = fit$covariate_data )
autoplot(Partial)

}

}
